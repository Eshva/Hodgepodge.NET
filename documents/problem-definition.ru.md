# Проблемы и прообразы решения

Далее примеры проблем и прообразов их решения, которые я имею в настоящий момент.

## Изучение Redis

Я начал использовать Redis в разработке продукта на работе. До этого я никогда его не использовал, да и в целом очень мало, если ни никогда, использовал не реляционные базы данных. ORM я "наелся" и считаю этот подход анти-паттерном. Да и нет для не реляционных баз данных каких-либо ORM. Поэтому приходится, и хочется, всё делать вручную. Но проблема состоит в том, что очень не хочется проверять сделанные в БД изменения с помощью каких-то GUI-инструментов или, не дай бог, с помощью командной строки. В случае с инструментами командной строки это медленно из-за необходимости выполнять много команд и интерпретировать их вывод. В случае с GUI-инструментами - долго ползать по их визуальным элементам управления. Хочется это делать программно в рамках того же кода, который выполняет изменения, не покидаю среду разработки и имея возможность тут же менять и расширять мои тесты.

Далее сценарий, который был бы мне удобен с использованием xUnit (я предпочитаю xUnit для написания тестов).

### Изучение основ работы с Redis и .NET-библиотекой для работы с ним

1. С помощью xUnit перед запуском набора тестов или отдельного теста, я создаю Redis-базу с нужным мне состоянием, например пустую или с уже предварительно созданными ключами нужных типов и содержанием.
2. В первой части теста я создаю необходимые объекты в базе данных.
3. Во второй части я проверяю их наличие и содержание.

### Изучение работы с кластером Redis

У Redis есть возможность настроить отказоустойчивый кластер (рассматривается именно отказоустойчивый кластер, а не кластер для шардирования). Для этих целей используется дополнительный компонент Sentinel. Для этого запускается несколько экземпляров Redis на разных машинах и настраивается их взаимодействие для выбора мастера. Иметь несколько машин для целей изучения - инициатива расточительная. Хотелось бы делать это всё на одной машине и опять же с использованием того же или похожего сценария, что для изучения основ Redis. В дополнение к нему, хотелось бы иметь возможность "убивать" определённый экземпляр или несколько и проверять с помощью тех же тестов в коде, как поведёт себя кластер.

### Прообраз решения

Для того, чтобы запускать один или несколько экземпляров Redis и сопутствующего программного обеспечения на любой машине, где будут запускаться эти тесты, удобнее всего использовать Docker-контейнеры. Точнее, чтобы не «заморачиваться» с управлением отдельными контейнерами, использовать Docker Compose или Kubernetes. Пожалуй, порог входа в Docker Compose ниже, чем в случае Kubernetes. Для этого нужно иметь некую библиотеку, позволяющую запускать, управлять и уничтожать контейнеры в составе проекта Docker Compose, выборочно или все вместе. Всё, что должно быть установлено для этого на машине:

* .NET Core Runtime
* Docker
* Docker Compose

При этом в процессе создания пакета тестов я хочу иметь возможность настроить Redis-сервер с помощью кода или конфигурационных данных, которые могу разместить в репозитории кода рядом с самим кодом. Например, было бы удобно иметь возможность настроить в коде следующие параметры:

* Запретить Redis записывать что-либо на диск и ограничиться работой только в памяти.
* TBD

## Интеграционные тесты

Модульные тесты -- это хорошо, но их мало. Часто в процессе разработки хочется писать какой-то компонент системы в связки с другими. 

### Разработка MediatR handler для взаимодействия с Redis-базой данных

В разработке продукта я использую Clean Architecture. Для низкой связанности кода, размещённого в разных слоях ответственности (Presentation и Application) я использую библиотеку MediatR. В качестве хранилища используется Redis-база данных. Данные хранятся в виде JSON-строк, для работы с которыми используется самописная библиотека-прослойка (хранится не только сам объект данных, но мета-информация о нём).

Есть желание при написании кода обработчика и теста к нему проверять не только результат вызова обработчика, но изменения в базе данных.

### Интеграционный тест для связки взаимодействующих запускаемых компонентов

Например, имеется stateful-микросервис, который взаимодействует с внешним миром по средствам REST API. Данный микросервис, как и положено stateful-микросервисам имеет некое дисковое хранилище, например, Redis-базу. Я хочу, вызывая методы ASP.NET контроллера, иметь возможность проверять результаты их выполнения, используя данные из Redis-базы. Опять же не ставя на своей машине Redis, не используя виртуалки или другие сторонние компьютеры, не покидая Visual Studio, не меняя своего языка программирования и привычек.

Можно несколько усложнить ситуацию. Например, у меня есть BFF, с которым работает браузерный клиент или мобильное приложение, stateful-микросервис, с которым работает BFF, чтобы получить/сохранить некоторые данные, Redis-база, в который эти данные и хранятся, и, скажем, сервер логирования, куда льют свои логи все эти компоненты.

Поскольку это несколько независимо собираемых и запускаемых компонентов, собрать и запустить их в рамках одного теста не получится без лишних "приседаний". Есть желание перенести эти хлопоты на плечи отдельного компонента, позволяющего с помощью кода и/или лежащих рядом с кодом тестов конфигурационных файлов.

Есть также желание иметь возможность запускать те же тесты в CI-конвейере без дополнительных изменений.

### Прообраз решения

Опять на помощь может прийти то же решение с использованием Docker Compose, но в данном случае необходимо не только запускать контейнеры из уже опубликованных Docker-образов, но и собирать эти образы из кода, расположенных в том же репозитории кода. При этом имея возможность вносить локальные изменения в несколько компонентов сразу без использования CI-конвейера, а значит и преждевременной выгрузки кода (`git push`) в общий репозиторий.